const express = require('express');
const bcrypt = require('bcryptjs');

const router = require('express').Router();

const { setTokenCookie, requireAuth } = require('../../utils/auth');
const { Spot, SpotImage, Review, Booking, User } = require('../../db/models');




// GET '/api/spots/current'
router.get('/current', requireAuth, async (req, res, next) => {
    const spots = await Spot.findAll({
        where: {
            ownerId: req.user.id
            // ownerId: 1
        }
    });
    return res.json({
        "Spots": spots
    })
})





//                              FROM REVIEWS

// Get all Reviews by a Spot's id
router.get('/:spotId/reviews', async (req, res, next) => {
    const { spotId } = req.params;
    const spot = await Spot.findByPk(spotId);

    if (!spot) {
        res.statusCode = 404;
        return res.json({
            "message": "Spot couldn't be found"
        })
    }

    const reviews = await Review.findAll({
        where: { spotId }
    })
    return res.json(reviews)

})

// Create a Review for a Spot based on the Spot's id
router.post('/:spotId/reviews', requireAuth, async (req, res, next) => {
    const { review, stars } = req.body;
    const { spotId } = req.params;

    // Body validation errors
    if (!review || !stars) {
        res.statusCode = 400;
        return res.json({
            "message": "Bad Request", // (or "Validation error" if generated by Sequelize),
            "errors": {
                "review": "Review text is required",
                "stars": "Stars must be an integer from 1 to 5",
            }
        })
    };

    const spot = Spot.findByPk(spotId);

    // Couldn't find spot by id
    if (!spot) {
        res.statusCode = 404;
        return res.json({
            "message": "Spot couldn't be found"
        })
    };

    try {
        const newReview = await Review.create({ userId: req.user.id, spotId, review, stars, });
        res.statusCode = 201;
        return res.json(newReview)

    } catch {
        //Review from the current user already exists for the Spot
        res.statusCode = 500;
        return res.json({
            "message": "User already has a review for this spot"
        })

    };

})



//
//
//                          FROM BOOKINGS
//
//

// Get all Bookings for a Spot based on the Spot's id
router.get('/:spotId/bookings', /* requireAuth, */ async (req, res, next) => {
    const { spotId } = req.params;
    const spot = await Spot.findOne({
        where: { spotId }
    });

    if (!spot) {
        req.statusCode = 404;
        return req.json({
            "message": "Spot couldn't be found"
        })
    }

    if (spot.ownerId === req.user.id) {
        return res.json({
            "Bookings": [
                {
                    spotId,
                    "startDate": spot.startDate,
                    "endDate": spot.endDate
                }
            ]
        })
    }
    return res.json({
        "Bookings": [
            {
                "User": req.user
            },
            spot
        ]
    })
});

router.post('/:spotId/bookings', /* requireAuth, */ async (req, res, next) => {
    const { spotId } = req.params;
    const { startDate, endDate } = req.body
    const currentDate = new Date().toString();
    const spot = await Spot.findByPk(spotId);

    // Error response: Couldn't find a Spot with the specified id
    if (!spot) {
        res.statusCode = 404;
        return res.json({
            "message": "Spot couldn't be found"
        })
    };

    // Error response: Booking conflict
    let bookings = await Booking.findAll({
        where: {
            spotId
        }
    });
    bookings = bookings.filter((booking) => booking.startDate.toString() < endDate.toString());
    bookings = bookings.filter((booking) => booking.endDate.toString() > startDate.toString());
    if (bookings.length) {
        res.statusCode = 403;
        return res.json({
            "message": "Sorry, this spot is already booked for the specified dates",
            "errors": {
                "startDate": "Start date conflicts with an existing booking",
                "endDate": "End date conflicts with an existing booking"
            }
        })
    }

    // Error response: Body validation errors
    if (startDate.toString() < currentDate.toString() || startDate.toString() > endDate.toString()) {
        res.statusCode = 400;
        return res.json({
            "message": "Bad Request", // (or "Validation error" if generated by Sequelize),
            "errors": {
                "startDate": "startDate cannot be in the past",
                "endDate": "endDate cannot be on or before startDate"
            }
        });
    };

    const newBooking = await Booking.create({ spotId, ...req.body });
    return res.json(newBooking)


});


// GET '/api/spots/:spotId'
router.get('/:spotId', async (req, res, next) => {
    const { spotId } = req.params;
    const spot = await Spot.findByPk(spotId)

    if (!spot) {
        res.statusCode = 404;
        return res.json({
            "message": "Spot couldn't be found"
        })
    }
    const spotImages = await SpotImage.findAll({
        where: { spotId },
        attributes: {
            exclude: ['updatedAt', 'spotId', 'createdAt']
        }
    });

    const owner = await User.findOne({
        where: {
            id: spot.ownerId
        },
        attributes: {
            exclude: ['createdAt']
        }
    })

    const response = {
        ...spot.toJSON(),
        "SpotImages": spotImages,
        "Owner": owner

    }
    return res.json(
        response)
})

// Edit a Spot
router.patch('/:spotId', /** requireAuth, */ async (req, res, next) => {
    const { spotId } = req.params;
    const updatedSpot = await Spot.findByPk(spotId);
    if (!updatedSpot) {
        res.statusCode = 404;
        return res.json({
            "message": "Spot couldn't be found"
        })
    }
    try {
        updatedSpot.set(req.body);
        await updatedSpot.save();
        return res.json(updatedSpot);
    } catch { //Error Response: Body validation errors
        res.statusCode = 400
        return res.json({
            "message": "Bad Request", // (or "Validation error" if generated by Sequelize),
            "errors": {
                "address": "Street address is required",
                "city": "City is required",
                "state": "State is required",
                "country": "Country is required",
                "lat": "Latitude must be within -90 and 90",
                "lng": "Longitude must be within -180 and 180",
                "name": "Name must be less than 50 characters",
                "description": "Description is required",
                "price": "Price per day must be a positive number"
            }
        })
    }
})

// Delete a spot
router.delete('/:spotId', async (req, res, next) => {
    const { spotId } = req.params;
    const deletedSpot = await Spot.findByPk(spotId);
    if (!deletedSpot) {
        res.statusCode = 404;
        return res.json({
            "message": "Spot couldn't be found"
        })
    }
    await deletedSpot.destroy();
    return res.json({
        "message": "Successfully deleted"
    })
})

// Add an Image to a Spot based on the Spot's id
router.post('/:spotId/images', /*requireAuth,*/ async (req, res, next) => {
    const { spotId } = req.params;
    const spot = await Spot.findByPk(spotId);

    if (!spot) {
        res.statusCode = 404
        return res.json({
            "message": "Spot couldn't be found"
        })
    }
    const newImage = await SpotImage.create({ spotId, ...req.body });
    return res.json(newImage)
})


// GET '/api/spots' Get all Spots
router.get('/', async (req, res, next) => {
    const spots = await Spot.findAll();
    return res.json(spots)
})

// Create a spot
router.post('/', /*requireAuth,*/ async (req, res, next) => {
    const { address, city, state, country, lat, lng, name, description, price } = req.body;

    try {
        const newSpot = await Spot.create({ ownerId: 1, address, city, state, country, lat, lng, name, description, price });
        res.statusCode = 201;
        return res.json(newSpot)
    } catch {
        res.statusCode = 400;
        return res.json({
            "message": "Bad Request", // (or "Validation error" if generated by Sequelize),
            "errors": {
                "address": "Street address is required",
                "city": "City is required",
                "state": "State is required",
                "country": "Country is required",
                "lat": "Latitude must be within -90 and 90",
                "lng": "Longitude must be within -180 and 180",
                "name": "Name must be less than 50 characters",
                "description": "Description is required",
                "price": "Price per day must be a positive number"
            }
        })
    }

})

module.exports = router;
